title=Do you fall prey to technical folk etymology?
date=2008-04-16
type=post
tags=reading, languages, industry
status=published
description=In which I discuss folk etymology and its relationship to our world.
~~~~~~

<!--more-->

<p>From <a href="http://en.wikipedia.org/wiki/Folk_etymology">Wikipedia</a> (itself a source of conceptual folk etymology, but that's another rant):</p> <ul> <ul> <li>A commonly held misunderstanding of the origin of a particular word, a false etymology</li> <li>"The popular perversion of the form of words in order to render it apparently significant"; "the process by which a word or phrase, usually one of seemingly opaque formation, is arbitrarily reshaped so as to yield a form which is considered to be more transparent"</li></ul></ul> <p>What do I mean by "technical folk etymology"? </p> <ol> <li>If you're a Java developer, consider the term <em>EJB</em>. No, I mean, seriously think about it for a moment. What images are conjured before your eyes when you do so? Horrendous APIs, hideous deployment requirements, complete untestability, and something that takes forty-five minutes to start?</li> <li>If you're a Ruby developer, consider the phrase <em>static typing</em>. Same sort of reaction?</li> <li>If you're a .NET developer, try on <em>COM</em> or <em>COM+</em> or even <em>ATL</em>. Mystifying collections of code repeated by rote, cut-and-pasted from that very first project you built by hand from <em>Inside OLE 2</em>, and once you got it to work, served as your basic template for every other COM/MTS/COM+ entity you ever built?</li> <li>Or, if you're any of these, how about <em>Visual Basic</em>?</li> <li>Or maybe <em>Web services</em>, specifically all those WS-* specifications?</li></ol> <p>As the MVP Summit Product Team dinners wound down here in Redmond tonight, I found myself at a table with (not surprisingly) Neal Ford and Venkat Subramaniam, two of my close friends from the NFJS tour, and who should join us but first Amanda Silver (lately of the Office team, but with her heart still firmly rooted in her Visual Basic dev days), then Don Box (lately of the Oslo team) and Chris Sells (also lately of the Oslo team), and a rousing discussion around the concept of DSLs--domain specific languages--arose, largely because Don wanted to sound out Venkat and Neal on the subject.</p> <p>Listening to the conversation (Don was mostly interested in Neal and Venkat's opinions, so I just relaxed and listened for the most part), I realized that the discussion was entirely rooted in this concept of <em>context</em>, that ephemeral structure surrounding a concept that gives it shape and color and taste and the other aesthetic qualities that lead us to "like" or "dislike" or "accept" or "reject" certain concepts. Don held the position--either for arguments' sake or because he believes it, I'm not sure which--that domain-specific languages lose context too easily once stored on the file system, in ways that data does not. His test was to suggest "What if a random piece of text drops into my email, how do I know what consumes this text?" The answer, of course, is that you don't, unless you somehow have a context by which to understand a piece of text, in many cases based solely on nothing more than filesystem extension, or MIME type, or the "#!/bin/..." line that precedes many shell scripts, and so on.</p> <p>Interestingly enough, as I drove home after the dinner, I realized that the conversation echoed an exchange Neal and Venkat and I were having in the car on the way over, about how Microsoft (I think) is making a <em>huge</em> mistake by looking to make C# more dynamic in nature[1]. My position was (and is) that Microsoft needs to differentiate the two key languages they offer--C# and Visual Basic--and an obvious way to do so would be to designate VB as the official "dynamic language" for the CLR, and C# as the official "static language" for the CLR, and encourage developers to use C# to build infrastructure (libraries and business types and so on) and VB to build "top of the stack" kinds of code (WinForms, ASP.NET, and so on).</p> <p>Neal put me squarely back on my heels with this (paraphrased) comment: Microsoft will never do this, because Visual Basic will <em>never</em> be able to shed the image it has gained, that of being the programming language for idiots[2].</p> <p>Wow.</p> <p>Sad thing is, he's right. Go back to the terms I suggested you think about at the top of this blog post. If you're like most Java developers, you heard the term "EJB" and immediately got a note of distaste in your mouth. You know that if you suggest EJB on your next Java project, you will be ridiculed and shamed and made to stand in the corner with the Dunce Cap on, <em>even if it makes complete sense from a technical perspective</em>. Companies are choosing instead to build their own transactional-oriented client/server middleware infrastructure, just to avoid the "shame" of using EJB. Because, as we all know, you just can't test EJB.</p> <p>Which, by the way, is a fallacy, and always has been. Oh, I know, you meant you can't <em>unit</em>-test EJB, but that's a fallacy too. It's <a href="http://openejb.apache.org/">always been testable</a>, to the same degree that any servlet application has been testable, it's just that nobody wanted to take the time to figure out how to test it effectively, particularly not once Rod Johnson had unleashed Spring upon the world and Made Everything Better(TM) (or, at least, XML configurable, which is better... right?).</p> <p>Static typing suffers the same kind of negative prejudice today. Suggest that C++ has a place in the world, and you will be kicked to the curb by any Right-Thinking Technical Leader. Suggest that C++ has a place on your next project, and you're likely to get sternly reprimanded, possibly even cut loose from the project. Suggest <em>anything</em> that doesn't fit with the Way We Build Software Today, and you're swimming upstream, either with management or with your fellow developers.</p> <p>All because they fall prey to technical folk etymology. They bend the context around the phrases in question to mean something entirely different than what the words actually mean, and as a result, the words take on an aura of snarling, bitter distaste, or, worse, angelic euphoric enlightenment.</p> <p>Domain-specific languages are the new phrase of the moment, and its emotional context is being built as we speak. Functional languages will be there sometime next year or the year after. For both, the euphoria is growing, and for each, in some period of <em>n</em> (three, maybe four) years will be crashing just as hard as they were built up, just as Ruby's and Visual Basic's and COM's and EJB's and WS-*'s and other technologies have done before it. It's as predictable as the flow of alcohol at an MVP Summit, or the consumption of either caffeine at an all-night code frenzy.</p> <p>Other industries have varying relationships with this notion of context: the medical field seems to be almost as susceptible to it as we are, particularly the area of weight management and holistic health (remember the water diet? the South Beach diet? the no-sodium diet? the low-cholesterol diet?), whereas traditional engineering disciplines, such as electrical and construction disciplines, seem far less vulnerable to "the hip new thing of the day". I'm not sure why this is, quite honestly, except that software and medicine share the similar characteristics of a rapid influx of new information on a regular, even daily, basis.</p> <p>People often call me a contrarian, a technical fuddy-duddy who refuses to embrace anything new or anything "bleeding-edge". In many respects, I welcome and accept that label, but frankly, I bristle at the implicit "you just don't want to learn anything new" accusation, because it's a gross misunderstanding and hideous misinterpretation of what I'm <em>really</em> trying to do: Distance myself from the emotional context surrounding a technology, and examine it through the lens of dispassionate observation.</p> <p>In short, I actively seek to defeat technical folk etymology, if only in the small area I personally can affect.</p> <p>Do you?</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>[1] <em>That particular discussion will have to wait for a different blog post on a different day.</em></p> <p>[2] <em>I should point out, before the hate mail comes flooding in, that this isn't Neal's own opinion, nor mine--witness my post on "Mort means productivity". What he--and I--refer to here is the reputation Visual Basic has garnered, not the fact surrounding it. And if you care to argue that point, then you're not paying attention to the relative average salary numbers between C# and Visual Basic developers. The laws of economics do not lie.</em></p>
 
