title=The Vietnam of Computer Science
date=2006-06-27
type=post
tags=jvm, java, j2ee, c++, ruby, xml services, scala
status=published
description=In which I offer up thoughts and reactions to the comments posted to my analogy about object/relational mapping and the problems it presents.
~~~~~~

Numerous folks have taken me to task (some here in comments, some through private email, some through still other channels) over the last blog post; rather than try to respond to all individually, I figured it makes more sense to address the more salient points here:

1. ***"How dare you use the Vietnam War as an analogy for something so trivial as object/relational mapping?"*** First of all, let's make a few facts clear. My father served in Vietnam. I have friends in Iraq right now. My best friend from high school served in the Navy during the first Iraq. I studied Vietnam--along with numerous other wars and coflicts--for several years as an International Relations major in college, focused specifically on military history. I have nothing but deep respect for all soldiers, of all nations, who go off to risk their lives in services to their country. I am appalled at how quickly governments (ours and others) chuck troops into a situation without thinking of the long-term strategy. I've spent more time studying war and its effects on the solidiers, the governments and the people than most people have spent watching TV. I am very aware of the ghosts I'm treading upon when I use the word "Vietnam", and quite frankly, folks, we as a nation have yet to come to terms with what happened there. Rambo films don't exorcise ghosts, much as we might want them to. POW-MIA flags don't, either. Please don't bring your ghosts in with you when approaching this subject, and I'll leave mine behind as well.

2. ***"The Vietnam War is a bad analogy for O/R-M."*** Vietnam remains, for most Americans, as the quintessential symbol for "bloody, ugly, unresolvable quagmire". And, as some have pointed out in comments on the blog post already, all analogies break down eventually, and this one is no different--as one commenter put it, nobody ever died from a bad O/R-M tool. (Though the day is not far off when such could occur, given the incredible spread of technology into all corners of our lives--it's not too hard to imagine a day when a patient dies because a doctor received incorrect information about a medical allergy from the enterprise system he/she uses to call up patient records.) That said, however, I assert that the analogy is appropriate, and relevant, for a variety of reasons. One, because just as development teams frequently believe that the object/relational problem is "solvable", so too did the US government believe that the Communist insurgency (which was more of an independence movement than a Communist movement, we've since realized) was "solvable" in South Indochina. Two, development teams frequently believe that with "just a little bit more work, we're almost there..." (wherever "there" is, in the minds of the architect or team lead), just as the US government frequently predicted that the Viet Cong were on the verge of defeat, just a few more troops and the war is over... Three, the analogy holds because even as team leads and architects approach this problem having been burned before, they still attempt solutions to the problem, just as many of the US administrations' advisors believed that Vietnam was a dead-end and ill-fated, they still went in there anyway.

3. ***"You aren't being fair--after all, {insert-name-of-favorite-O/R-M-tool-here} doesn't suffer from that problem."*** Not yet, it doesn't. Or it does, but you just haven't run into it yet. Either answer is possible. And in the early years of the Vietnam conflict, we didn't suffer the problems that we commonly associate with the War--the poor morale, the rampant drug use among the military, the widespread unpopularity of the conflict back home, and so on. The danger here is on the far end of the Slippery Slope, not the near end.

4. ***"You aren't being fair--when you balance the pros and cons..."*** Perhaps not. But as someone who's built three O/R-M's in his lifetime, and refuses to build another one because they all faced the same end, despite very different beginnings, I worry more about the Slippery Slope and where it leaves us in the end. If your team can stay perched on the side of the Slope that yields the most benefits, then more power to you; but I worry about the day when the new college intern says to himself, "You know, with a bit more investment, I bet we could add inheritance...."

5. ***"Some languages do allow for varying numbers of fields."*** Actually, no, most of the languages cited as examples, including Ruby, don't allow for varying fields. Ruby has a feature called "open classes", in which you can change the definition of the class at any time, but it's still (very loosely) a class-based language. (The implementation of Ruby, from what I can see, seems to back this point--each object holds a pointer back to the class object it stems from, which means, at least to me, it's loosely class-based.) We can debate the semantics of this point for days, and frankly I welcome the discussion, but not in the context of this one. We can save that for another post/thread at another time.

6. ***"OK, but where can I go to get more info about O/R-M so I don't fall into the quagmire?"*** Excellent question. Roy Osherove has started a community site about O/R-Ms, which I think holds promise for discussion on the topic. The JDO crowd had several resources available at JDOCentral, and there's lots of discussion about O/R-M (stretching back several years) on TheServerSide. BEA, with its acquisition of Solarmetric, now owns one of the better O/R-M tools on the market, Kodo, and they're likely to still have numerous white papers and such on the subject.

7. ***"OK, but where can I go to get more info about object persistence tools?"*** Right now, the only one I have any faith in is the db4o project; in fact, I'm speaking at their first user/developer conference in London in a few weeks. I've used others (such as Versant) in the past, and frankly, wasn't incredibly impressed.

8. ***"OK, but where can I go to get more info about these other languages/approaches?"*** Keep your eye on LINQ, for starters, as that's one of the first mainstream attempts to bring some of these ideas into traditional statically-typed object platforms. Scala and F# I already mentioned. Ruby is another place to spend some time, as there's a lot of features Ruby has that are trying to make their way into other languages. And, although I will likely gather some serious heat for saying this, Visual FoxPro may have some of the most interesting "best of both worlds" mojo in the entire language space on this subject.

9. ***"Great post!"*** Thanks.

Make no mistake about it: I am deeply sympathetic to anyone who lost somebody--figuratively or literally--to the Vietnam conflict. I feel equally sympathetic to anyone who lost somebody in the Korean War (as my family did), World War Two, or even World War One before that. In fact, my sympathies go out to anyone lost in any of the conflicts across history and the globe in which men and women die for an ideal or symbol. It is an unfortunate statement about human affairs that we see war as the ultimate arbiter over power disputes between nations, but this is the world we live in now. If you don't care for that, then I encourage you to actively work to change it, regardless of your politics. I have far more respect for someone who virulently disagrees with my political viewpoints and actively promotes their own, than I do for those who agree with my politics and do nothing but complain.

Perhaps history will record Vietnam as America's greatest military failure, perhaps not. There is ample evidence to suggest that Vietnam will forever act as a check on American territorial expansionism (remember, Hawaii and Alaska gained statehood after World War Two), and more importantly, as a checkpoint to hold flagrant use of American military muscle in place. But be that as it may, the fact remains that Vietnam had an incalculable effect on American foreign policy and domestic agenda, and will continue to do so for the next several generations. And, as numerous examples from my own experience and others can attest, the use of O/R-M can have the same effect (relativisitically speaking) on a development team's efforts.

---

***2023 Thoughts and Edits:*** A decade and a half after I wrote this, the essay remains just as actively and hotly debated as ever, so I thought it would be appropriate to revisit some of the thoughts from 17 years ago.

***Outrage over war as an analogy.*** Look, let's get past that right now. When certain media pundits are screaming about a "War on Christmas", we've clearly lost all sense of the term "war". More to the point, what most people mean by "war" is what the political scientists refer to as "total war"--the complete commitment of every aspect of national life to the victorious conclusion of some military conflict. Honestly, that term didn't apply to the US involvement in Vietnam, either, so if we're going to debate this further, we need to start being really precise with our terminology and analogies, and it just isn't worth it.

***O/R-M tool doesn't suffer from that problem....*** Yeah, turns out they all did, somewhere along the line.

***"But wait! NoSQL! NewSQL! Multimodel databases!"*** Oh, this gets interesting, and possibly meriting an essay of its own sometime. Suffice it to say that the impedance mismatch of objects to relations doesn't apply when the database stores document, but then we're dealing with the impedance mismatch of objects to documents. Data's "shape" doesn't get any less "shaped" just because it's different from what it used to be.

***"You didn't understand dynamic languages well enough!"*** I heard this more than a few times over the last 17 years, and I don't quite know how to tell people that "yes, I *do* understand dynamic languages" other than to say, yes, your language of choice (Python, Ruby, Javascript, and a few others to boot) certainly have the metaobject capabilities to add new fields to an existing class, but all of that has to happen at runtime, and unless the database metadata is verified as part of the exercise, it's still not verified and therefore subject to some of the same typos and errors that a schema-validating database is supposed to protect you from.

***"What ever happened to...?"*** Sadly, LINQ decided that it wasn't as interested in doing more to combine sets and objects, and instead Microsoft chose to put all their work into Entity Framework with a LINQ provider on top of that, despite the fact that LINQ could've actually really tackled this whole thing quite effectively. *sigh* No other language I've seen has come quite that close, although there's been some interesting multi-model languages in the academic arena that have explored this idea, and (I thought) had some promising successes. But in the meantime, in the mainstream languages, we are still no further along than we were almost two decades ago.

Which is what I find the saddest part of everything.
