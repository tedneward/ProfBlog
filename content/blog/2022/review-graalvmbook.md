title=Book review: Supercharge Your Applications with GraalVM
date=2022-02-23
type=post
tags=jvm, review, graalvm
status=published
description=A review of the book "Supercharge Your Applications with GraalVM".
~~~~~~

A while back, Packt Publishing asked me to do a review of the book ["Supercharge Your Applications with GraalVM"](https://www.packtpub.com/product/supercharge-your-applications-with-graalvm/9781800564909), and while I wrote it up, I never pushed it to the blog. tl;dr, it's a decent book--a good intro to GraalVM, with some interesting tidbits in there, but not deep enough for the expert. (Full disclosure: Packt sent me a copy of the book in exchange for a review.)

<!--more-->

For those Java developers who’ve never heard of or never explored [GraalVM](https://www.graalvm.org/), the latest virtual machine technology project courtesy of Oracle Labs, it may be unclear why the world needs another virtual machine--after all, HotSpot did wonders for most Java applications when it came out in JDK 1.2 (circa 2000), and the caretakers of the JVM have been tinkering and making significant changes to the performance ever since. Garbage collectors, bytecode translation, you name it, they’ve tinkered with it. So the average Java developer could be forgiven if they were to see GraalVM, and think, "Yeah, whatever."

A B Vijay Kumar’s book, ***Supercharge Your Applications with GraalVM***, will go to great lengths to dissuade Java developers of that naïve notion. While the book itself could use with a bit better "overarching story", explaining how the different features of GraalVM tie together and present a coherent whole, it’s not like the GraalVM documentation does a much better job of that; instead, the various features are laid out, and it’s left to the reader (or user of GraalVM) to figure out where and how each significant piece of the platform "fits".

The first criticism I might have of the book is that it doesn’t always seem to consistently know who its audience is. Chapters 1 and 2 go over some of the core basics of the JVM; Chapter 1 covers the C1 and C2 bytecode compilers, for example, which for any student of the JVM is pretty redundant. Chapter 2, though, introduces JITWatch and the `+XX:PrintCompilation` flag, which is generally something reserved for the serious VM explorer. While I suppose it’s possible one could go from "lightweight intro" to "serious player" in a fairly fast manner, doing so in two book chapters seems like a leap.

Chapter 3 begins the serious exploration of GraalVM itself, getting into the architecture of the system. It’s also the first hint the reader gets that GraalVM is more than "just" an upgraded JVM; in fact, it’s fair to suggest that GraalVM may very well be the last virtual machine anyone would ever need to write, thanks to its "Polyglot" support: GraalVM can run not only Java bytecode, but Python, R, Ruby, even C/C++ and Web Assembly (WASM) code. This support, known as "Truffle", is what gives GraalVM the ability to do ahead-of-time (AOT) native compilation of Java applications, which is what most of the Java industry conference speakers focus on, particularly since that native AOT compilation is what will make microservices spin up faster. However, that’s merely the surface of the subject.

Chapter 4 then dives into getting GraalVM installed and hooking up the various performance monitoring tools (like VisualVM); this chapter felt a little out-of-place to me, since I would’ve expected to see it earlier--or later--in the conversation based on the previous chapter. He also introduces another tool, the Idea Graph Visual izer, which analyzes how Graal JIT-compiles code. This doesn’t exactly feel in line with the "getting started" vibe from the earlier parts of the chapter, though the utility of the tool is pretty much self-evident. It does require Kumar dive into some compiler theory 101 kinds of topics (intermediate representations, static-single-assignment (SSA) form, and so on), which means now in one chapter we are getting started, seeing a new tool exploring the JIT compiler, and learning some core ideas of compilation, all in one span of text. It feels a little rushed at times, a little too compact, and a little out of order.

Chapter 5 then dives into a tutorial on building native images and running them with profile-guided optimization (PGO). This was really the first part of the book where one could get "hands on" with what was being taught, and I felt it needed to come sooner, probably right after getting GraalVM installed. These two chapters (4 and 5) were the most "muddled" in my mind, where it felt like the author was jumping around between some topics without a clear path in mind or a clear rationale for why we needed to read about "A" before we read about "B". In all fairness, though, that may be my own biases and prejudices coming to the fore--I’ve spent enough time writing books and teaching workshops that I pay careful attention to that "journey" the reader or student will take through the material.

Chapters 6 through 9 explore the polyglot nature of GraalVM, introducing the Truffle framework in greater depth, then exploring how to run different language-based code on top of the runtime. GraalVM can execute not only Java bytecode, but also NodeJS, Python, Ruby, or R (from their respective sources) and WebAssembly and C/C++ (through the use of the LLVM toolchain, which is a native compilation framework that many languages use to generate native code). To my mind, this is where the GraalVM story is the most interesting, and the author provides some simple examples, but I would’ve preferred a little more depth around each of the different languages and some of the integration challenges that arise.

Finally, in Chapter 10, Kumar gets to what most people will think is the real *raison d’être* of GraalVM: microservices. Accordingly, the chapter opens with a brief introduction of microservices which I found entirely unnecessary (does anybody not know what those are by now?) and then proceeds to build out an example of an application built out of microservices. The author then takes one of the services and builds it out using a variety of different microservice frameworks (Spring Boot, Micronaut, Quarkus). Frankly, I found this chapter pretty gratuitous, as if the publisher insisted that the book couldn’t be published unless it had microservices somewhere in it--it just feels that much out of place compared to the rest of the material. Still, for a lot of readers who are looking for answers to their day-job needs, it’s a reasonable demonstration of how GraalVM could be applied to a microservice-based architecture.

***In summation:***
For the virtual machine expert or aficionado, parts of the book will seem redundant, but for those who’ve never really spelunked below the surface of the Java (or Groovy or Scala or Kotlin or...) code they write, the book will offer just enough background to the subject to feel comfortable reading other resources, or enough to take what Kumar says through the rest of the book on faith. While Kumar’s writing is pretty clear and straightforward, the outline through the material is less so, and it feels like the book would’ve benefited strongly from a firm editorial hand to create more of a "journey" through the GraalVM landscape. Still, the words-to-concepts ratio means the material is dense enough to keep the reader from being bored or flipping through the pages too quickly, and that’s a plus. Additionally, it’s a useful guide for those who aren’t comfortable going directly to the documentation to learn how to use GraalVM.

If you’ve never heard of GraalVM or heard only rumors and want a hearty introduction into all the things GraalVM offers, this is a good book with which to get started, though I wouldn’t expect it to be one used over and over again once read cover-to-cover.

***Overall verdict: 4 stars out of 5***
