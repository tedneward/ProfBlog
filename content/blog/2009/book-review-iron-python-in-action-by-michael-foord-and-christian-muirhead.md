title=Book Review: Iron Python in Action
date=2009-07-01
type=post
tags=review, reading, industry, languages, python, clr
status=published
description=In which I examine the book and provide my thoughts on it.
~~~~~~
*Iron Python in Action* (Michael Foord, Christian Muirhead; Manning)

<!--more-->

<p>OK, OK, I admit it. Maybe significant whitespace isn't all bad. (But don't let me ever catch you quoting me say that.)</p>  <p>The reason for my (maybe) shift in thinking? Manning Publications sent me a copy of <em>Iron Python in Action</em>, and I have to say, I like the book and its approach. Getting me to like Python as a primary language for development will probably take more than just one book can give, but... *shrug* Who knows?</p>  <p>Bear in mind, I have plenty of reasons to like IronPython (Microsoft's Python implementation for the .NET environment):</p>  <ul>   <li>A good friend of mine, Harry Pierson (aka @DevHawk), is the PM on the IPy project, and I'm generally prejudiced in favor of those things that people I know and respect.</li>    <li>I'm generally a fan of dynamic languages, particularly those that let you do strange and twisted things to the type system and its instances at runtime. (Yes, I'm looking at you, ECMAScript...)</li>    <li>I spent some quality time with IronPython Studio last year while researching a Visual Studio Extensibility &quot;Deep Dive&quot; paper.</li>    <li>I've known Jim Hugunin (the creator of IronPython, and Jython before that) for some years, ever since his days working on AspectJ, and he's one of those scary-smart guys that, despite knowing they're scary-smart, still render me stunned when I listen to them.</li>    <li>I'm a huge fan of the DLR. It's like having Parrot, but without having to wait a decade (give or take).</li> </ul>  <p>But, just to counterbalance the scales, I have plenty of good reasons to dislike IronPython, too:</p>  <ul>   <li>Significant whitespace.</li>    <li>The &quot;There's only one way to do it&quot; oath that Pythonistas seem to hold as religion. (Somebody told me that building C-Python—the original implementation—only works for you if you swear a holy oath to The One True Way on the One True Way Bible. Needless to say, I believe them, and have never tried to build C-Python from sources as a result.)</li>    <li>Significant whitespace.</li>    <li>Uh.... did I mention significant whitespace yet?</li> </ul>  <p>I admit, it was with some hesitation that I cracked open the book. Actually, to be honest, I was really ready to just take out all my dislike of significant whitespace and pour it into a heated, vitriolic diatribe on everything that was just <em>wrong</em> with Python.</p>  <p>And...?</p>  <p>Well, OK, I admit it. Maybe significant whitespace isn't all bad.</p>  <p>But this is a review of the book, not the technology. So, on we go.</p>  <h3>What I liked about the book</h3>  <ul>   <li>The focus is on both .NET and Python, and doesn't try to short-change either the &quot;Python&quot;-ness or the &quot;.NET'-ness by trying to be a &quot;Python book (that happens to run on .NET)&quot; or a &quot;.NET book (that happens to use Python for code samples)&quot;. The authors, I think, did a very good job of balancing the two, making this <em>the</em> book to get if you're in that area on the Venn diagram where &quot;Python&quot; overlaps with &quot;.NET&quot;.</li>    <li>Part 2, <em>&quot;Core development techniques&quot;</em>, starts down the &quot;feed you the Python Kool-Ade&quot; pretty quickly, heading straight into Chapter 4 (&quot;<em>Writing an application and design patterns with IronPython&quot;</em>) without much of a pause for breath. The authors get into duck typing, protocols, and Model-View-Controller within the first four pages, and begin working on a running example to highlight some of the ideas. (Interestingly enough, they also take a few moments to point out that IronPython on Mono works, and include a couple of screen shots to that effect as we go, though I personally wonder just how many people are really going down this path.) I like the no-holds-barred, show-you-the-code style, but only because they also take time throughout the prose to talk about some of the concepts at work underneath and laced throughout the code. &quot;Show me then tell me&quot; is a time-honored tradition, but too many authors forget the &quot;tell me&quot; part and stop with code. These guys do a good job of following through.</li>    <li>The chapters in Part 3, &quot;<em>IronPython and advanced .NET</em>&quot;, form an interesting collection of how IronPython can fit into the rest of the .NET stack, demonstrating how to use IronPython with WPF, ASP.NET, and IronPython's crowning glory, Silverlight. If you're into front-end stuff, this is the section where I think you're going to have the most fun.</li>    <li>The chapters in Part 4, &quot;<em>Reaching out with IronPython</em>&quot;, is I think the most important part of the book, showing how to extend IronPython (chapter 14) with C#/VB extensions (similar to how a C-Python developer would extend Python by writing C code, but much much simpler) and the opposite—how to embed IronPython inside of existing C#/VB applications (chapter 15), which is really an exercise in using the DLR Hosting APIs. While the discussion in chapter 15 is good, I wish it'd had a bit more thorough discussion of how the DLR could be hosted regardless of the scripting language, though I admit that's pretty beyond the scope of this book (which is focused, after all, entirely on IronPython, and as a result <em>should</em> stay focused on how to host IPy).</li> </ul>  <h3><strong>What I found &quot;Meh&quot; about the book</strong></h3>  <ul>   <li>Part 1 (<em>&quot;A new language for .NET&quot;</em>, <em>&quot;Introduction to Python&quot;</em>, and <em>&quot;.NET objects and IronPythong&quot;</em>) does a good job of bringing the rank beginner up to speed, getting some basic Python ideas across in the same breath that they bring .NET home. The only problem is, it only works well if you're neither a Python programmer nor a .NET programmer. Chapter 1, for example, does a sort of Cannonball-into-the-pool kind of dive into Python, but dives equally into the &quot;Iron&quot; parts as it does the &quot;Python&quot; parts. If you're either a Pythonista or a .NETter, I suspect you're going to be tempted to flip pages pretty quickly, and (I suspect) miss a few things. Chapter 2 is all about Python (meaning .NETters will probably spend some time here), but it certainly doesn't feel like an exhaustive reference, nor does Chapter 3 stand as an exhaustive discussion about all things .NET, either. I almost wish all three chapters had been collapsed into one—suffice it to say, I don't feel like I know the Python language, and don't feel like this book could be my Python reference next to me as I learn it, and I know that it's not a great .NET reference, either. Fortunately, the goal of these three chapters feels pretty clearly to be &quot;Teach you just enough to make you dangerous (and able to understand the rest of the book)&quot;, and once we hit Part 2, rubber meets road pretty quickly.</li>    <li>By the time you hit Chapter 7, less than halfway through the book, the authors have created a fairly nice, if simplistic, application for later dissection, but it's not until you hit Chapter 7 that they begin to start unit-testing, even though they insist (on page 17) that &quot;Dynamic language programmers are often proponents of <em>strong testing rather than strong typing</em>&quot; (a quote they attribute to Bruce Eckel, though I'm relatively certain I heard Dave Thomas and Neal Ford say it with respect to Ruby, long before Eckel started &quot;Thinking in Python... or Flex... or whatever&quot;). If unit-testing is that important, why wait three chapters into the application's development before writing a single unit-test? This doesn't jibe with me, somehow.</li>    <li>If you're into back-end stuff, chapter 12 on <em>&quot;Databases and web services&quot;</em> is pretty bland. The fact that the two are combined into a single chapter is indicative, all by itself, of how deep or intensive the coverage goes, and there's zero mention of anything beyond basic ADO.NET. The coverage on web services covers REST relatively well, but there's zero coverage of WCF, and the whole of SOAP-based services is all of four or five pages. And Workflow? Doesn't exist, isn't even mentioned (except for an appearance in a table, &quot;The major new APIs of .NET 3.0&quot;). Yikes.</li> </ul>  <h3><strong>What I actively disliked about the book</strong></h3>  <p>Actually, not much. Manning did their usual superb job of arrowed callouts to point out particular concepts in the code listings, the copyediting is professional (meaning there's no obvious typos or misspellings that just break up the flow of prose, something that not all publishers seem to take seriously), and the graphics flow nicely alongside the prose, not dominating the page but accentuating it.</p>  <p>In fact, about the only thing I'd care to criticize is the <em>huge</em> number of footnotes, particularly in the first chapter. (By page 20 in the book, there have already been 30 footnotes.) When you have three footnotes <em>per page</em>, on average (and sometimes more), it does tend to distract, at least to me it does. It feels like there were ways, for most of them, to inject the idea or concept into the main prose, or leave it out entirely, but that could just be a difference of writing style, too.</p>  <h3><strong>Summation</strong></h3>  <p>If you're a .NET developer interested in learning/using IronPython on your next project, this is a definite winner. If you're a Python developer looking to see how to break into .NET, I'm not so sure this is your book, but I say that mostly because I'm <em>not</em> a Pythonista and can't really speak to how that mindset will find this as an introduction to the .NET space. My intuition tells me that this would be a good springboard into another book on .NET for the Python programmer, but I'll have to leave that to Pythonistas who've read this book to comment one way or another.</p>
 
