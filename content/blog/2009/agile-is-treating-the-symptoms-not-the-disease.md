+++
date = "2009-10-12T16:51:39.8756711-07:00"
draft = false
title = "\"Agile is treating the symptoms, not the disease\""
aliases = [
	"/2009/10/12/quotAgile+Is+Treating+The+Symptoms+Not+The+Diseasequot.aspx"
]
categories = [
	".NET","C#","C++","Conferences","F#","Flash","Industry","Java/J2EE","Languages","Mac OS","Parrot","Python","Reading","Ruby","Scala","Social","Solaris","Visual Basic","WCF","Windows"
]
concepts = ["Industry", "Languages", "Reading", "Social"]
languages = ["C#", "C++", "F#", "Python", "Ruby", "Scala", "Visual Basic"]
platforms = [".NET", "Java/J2EE", "Mac OS", "Parrot", "Windows"]
 
+++
<p>The above quote was tossed off by Billy Hollis at the patterns&amp;practices Summit this week in Redmond. I passed the quote out to the Twitter masses, along with my +1, and predictably, the comments started coming in shortly thereafter. Rather than limit the thoughts to the 120 or so characters that Twitter limits us to, I thought this subject deserved some greater expansion.</p>  <p>But before I do, let me try (badly) to paraphrase the lightning talk that Billy gave here, which sets context for the discussion:</p>  <ul>   <li>Keeping track of all the stuff Microsoft is releasing is hard work: LINQ, EF, Silverlight, ASP.NET MVC, Enterprise Library, Azure, Prism, Sparkle, MEF, WCF, WF, WPF, InfoCard, CardSpace, the list goes on and on, and frankly, nobody (and I mean nobody) can track it all.</li>    <li>Microsoft released all this stuff because they were chasing the &quot;enterprise&quot; part of the developer/business curve, as opposed to the &quot;long tail&quot; part of the curve that they used to chase down. They did this because they believed that this was good business practice—like banks, &quot;enterprises are where the money is&quot;. (If you're not familiar with this curve, imagine a graph with a single curve asymptotically reaching for both axes, where Y is the number of developers on the project, and X is the number of projects. What you get is a curve of a few high-developer-population projects on the left, to a large number of projects with just 1 or 2 developers. This right-hand portion of the curve is known as &quot;the long tail&quot; of the software industry.)</li>    <li>A lot of software written back in the 90's was written by 1 or 2 guys working for just a few months to slam something out and see if it was useful. What chances do those kinds of projects have today? What tools would you use to build them?</li>    <li>The problem is the complexity of the tools we have available to us today preclude that kind of software development.</li>    <li>Agile doesn't solve this problem—the agile movement suggests that we have to create story cards, we have to build unit tests, we have to have a continuous integration server, we have to have standup meetings every day, .... In short, particularly among the agile evangelists (by which we really mean <em>zealots</em>), if you aren't doing a full agile process, you are simply failing. <em>(If this is true, how on earth did all those thousands of applications written in FoxPro or Access ever manage to succeed? –-Me)</em> At one point, an agilist said point-blank, &quot;If you don't do agile, what happens when your project reaches a thousand users?&quot; As Billy put it, &quot;Think about that for a second: This agile guy is <em>threatening</em> us with success.&quot;</li>    <li>Agile is for managing complexity. What we need is to recognize that there is a place for outright simplicity instead.</li> </ul>  <p>By the way, let me say this out loud: if you have not heard Billy Hollis speak, you should. Even if you're a Java or Ruby developer, you should listen to what he has to say. He's been developing software for a long time, has seen a lot of these technology-industry trends come and go, and even if you disagree with him, you need to listen to him.</p>  <p>Let me rephrase Billy's talk this way:</p>  <blockquote>   <p><em>Where is this decade's Access?</em></p> </blockquote>  <p>It may seem like a snarky and trolling question, but think about it for a moment: for a decade or so, I was brought into project after project that was designed to essentially rebuild/rearchitect the Access database created by one of the department's more tech-savvy employees into something that could scale beyond just the department. </p>  <blockquote>   <p><em>(Actually, in about half of them, the goal wasn't even to scale it up, it was just to put it on the web. It was only in the subsequent meetings and discussions that the issues of scale came up, and if my memory is accurate, I was the one who raised those issues, not the customer. I wonder now, looking back at it, if that was pure gold-plating on my part.)</em></p> </blockquote>  <p>Others, including many people I care about (Rod Paddock, Markus Eggers, Ken Levy, Cathi Gero, for starters) made a healthy living off of building &quot;line of business&quot; applications in FoxPro, which Microsoft has now officially shut down. For those who did Office applications, Visual Basic for Applications has now been officially deprecated in favor of VSTO (Visual Studio Tools for Office), a set of libraries that are available for use by any .NET application language, and of course classic Visual Basic itself has been &quot;brought into the fold&quot; by making it a fully-fledged object-oriented language complete with XML literals and LINQ query capabilities.</p>  <p>Which means, if somebody working for a small school district in western Pennsylvania wants to build a simple application for tracking students' attendance (rather than tracking it on paper anymore), what do they do?</p>  <p>Bruce Tate alluded to this in his <em>Beyond Java</em>, based on the realization that the Java space was no better—to bring a college/university student up to speed on all the necessary technologies required of a &quot;productive&quot; Java developer, he calculated at least five or six weeks of training was required. And that's not a bad estimate, and might even be a bit on the shortened side. You can maybe get away with less if they're joining a team which collectively has these skills distributed across the entire team, but if we're talking about a standalone developer who's going to be building software by himself, it's a pretty impressive list. Here's my back-of-the-envelope calculations:</p>  <ul>   <li>Week one: Java language. (Nobody ever comes out of college knowing all the Java language they need.)</li>    <li>Week two: Java virtual machine: threading/concurrency, ClassLoaders, Serialization, RMI, XML parsing, reference types (weak, soft, phantom).</li>    <li>Week three: Infrastructure: Ant, JUnit, continuous integration, Spring.</li>    <li>Week four: Data access: JDBC, Hibernate. (Yes, I think you need a full week on Hibernate to be able to use it effectively.)</li>    <li>Week five: Web: HTTP, HTML, servlets, filters, servlet context and listeners, JSP, model-view-controller, and probably some Ajax to boot.</li> </ul>  <p>I could go on (seriously! no JMS? no REST? no Web services?), but you get the point. And lest the .NET community start feeling complacent, put together a similar list for the standalone .NET developer, and you'll come out to something pretty equivalent. (Just look at the <a href="http://www.pluralsight.com/main/ilt/Courses.aspx" target="_blank">Pluralsight list of courses</a>—name the <em>one</em> course you would give that college kid to bring him up to speed. Stumped? Don't feel bad—I can't, either. And it's not them—pick on any of the training companies.)</p>  <p>Now throw agile into that mix: <em>how does an agile process reduce the complexity load?</em> And the answer, of course, is that it doesn't—it simply tries to muddle through as best it can, by doing all of the things that developers need to be doing: gathering as much feedback from every corner of their world as they can, through tests, customer interaction, and frequent releases. <em>All of which is good</em>. I'm <em>not</em> here to suggest that we should all give up agile and immediately go back to waterfall and Big Design Up Front. Anybody who uses Billy's quote as a sound bite to suggest that is a subversive and a terrorist and should have their arguments refuted with <em>extreme prejudice</em>.</p>  <p>But agile is not going to reduce the technology complexity load, which is the root cause of the problem.</p>  <p>Or, perhaps, let me ask it this way: your 16-year-old wants to build a system to track the cards in his Magic deck. What language do you teach him?</p>  <p>We are in <em>desperate</em> need of simplicity in this industry. Whoever gets that, and gets it right, defines the &quot;Next Big Thing&quot;.</p>
 
